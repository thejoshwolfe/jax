
first read README.txt, then this document.

Phases of compiling (see Main.comprehend():
1. Tokenization - generates an array of tokens
2. Parsing - generates and Abstract Syntax Tree
3. Lexiconization (or Lexical Analysis for you traditionalists) - fills in the AST with contextual info
4. Optimization (optional) - reduces the AST when possible
5. Code Generation - generates a .class file

See test/README_tests.txt for testing/demo info.


The parsing grammar of the language is coded out in "jax.jape". The class Parser and the classes in
net.wolfesoftware.java.jax.ast could almost be generated by a parser generator if it weren't for additional
fields in the classes (like FunctionDefinition.returnType). I don't have any plans to make a parser
generator for the .jape grammar.


If you'd like to help out, you can search for "TODO" (eclipse tasks) throughout the code.

Also, there's a lot to do in the Optimizer. An easy one would be inlining the contents of a Quantity.

