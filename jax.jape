
###
### Josh's Jax grammar definition file
###

## how the grammar works:
## types of grammar elements:
## 	scalar:
## 	 declaration prefixed with "$"
##   elements listed delimited by whitespace
##   indicates that all elements should appear in the order specified
##  list:
##   declaration prefixed with "~"
##   element type and delimiter token specified with a ":" between them
##   indicates that zero or more occurrences of the element appear separated by the delimiter
##   when the element type is surrounded in parens, it means elements between and around delimiters are optional (ex: {1,2,,3,}, {,,})
##  switch:
##   declaration prefixed with "|"
##   choices listed delimited by "|"
##   indicates that exactly one of the choices should appear
##  recursive prototype:
##   prototype definition prefixed with "/"
##   actual definition appears later and is one of scalar, list, or switch
##  special predefined elements:
##   begin with a "!"
##   there are only a few such as !Root. I hope what they do is self explanitory.
##
## declared element names must be all letters in TitleCase. /[A-Z][A-Za-z]*/ I recommend TitleCase because they will be the names of Java classes.
##
## all elements must be declared or prototyped before they are referenced in a definition.
## scalars with head- or tail-recursion must specify a precedence in parentheses following the reference to the prototyped element.
##
## primitive elements: 
##  LITERAL - indicates a literal value (integers, Strings, etc)
##  ID - indicates an identifier.
##
## literal elements:
##  elements specified in quotes (") signify keywords or symbol tokens
##
## special elements

### Types
|PrimitiveType = "void" | "int" | "boolean"
|ScalarType = PrimitiveType | ID
|ArrayDimension = "[" "]"
~ArrayDimensions = ArrayDimension : ""
$TypeId = ScalarType ArrayDimensions

### variable declaration
$VariableDeclaration = TypeId ID

### recursive expressions
/Expression

    ### binary operators (precedence choices from http://java.sun.com/docs/books/tutorial/java/nutsandbolts/operators.html)
    $Addition = Expression(110) "+" Expression(111)
    $Subtraction = Expression(110) "-" Expression(111)
    $Multiplication = Expression(120) "*" Expression(121)
    $Division = Expression(120) "/" Expression(121)
    $PreIncrement = "++" Expression(131)
    $PreDecrement = "--" Expression(131)
    $PostIncrement = Expression(140) "++"
    $PostDecrement = Expression(140) "--"
    |Arithmetic = Addition | Subtraction | Multiplication | Division
    $LessThan = Expression(90) "<" Expression(90)
    $GreaterThan = Expression(90) ">" Expression(90)
    $LessThanOrEqual = Expression(90) "<=" Expression(90)
    $GreaterThanOrEqual = Expression(90) ">=" Expression(90)
    $Equality = Expression(80) "==" Expression(81)
    $Inequality = Expression(80) "!=" Expression(81)
    |Comparison = LessThan | GreaterThan | LessThanOrEqual | GreaterThanOrEqual | Equality | Inequality 
    |InfixOperation = -Arithmetic | -Comparison

    ### unary prefix operators
    #$Negation = "-" Expression(140)
    #|PrefixOperation = Negation

    |Operation = -InfixOperation # | -PrefixOperation

    #### function invocation
    ~Arguments = Expression : ","
    $FunctionInvocation = ID "(" Arguments ")"

    ### variable initialization
    $VariableCreation = VariableDeclaration "=" Expression

    ### Control Structures
    $IfThen = "if" Expression "then" Expression
    $IfThenElse = "if" Expression "then" Expression "else" Expression
    $ForLoop = "for" "(" Expression ";" Expression ";" Expression ")" Expression
    |ControlStructure = IfThen | IfThenElse | ForLoop

    ### controlStatement (continue, return, etc.)
    #|ControlStatement = 

    ### block
    ~BlockContents = (Expression) : ";"
    $Block = "{" BlockContents "}"

    $Assignment = ID "=" Expression

    # dereferencing
    $DereferenceField = Expression(150) "." ID
    $DereferenceMethod = Expression(150) "." FunctionInvocation
    $StaticDereferenceField = TypeId "." ID                       # These two are impossible to distinguish from the above two at the
    $StaticFunctionInvocation = TypeId "." FunctionInvocation     # Parsing stage. The Lexiconizer has to swap in these when appropriate.
    $ArrayDereference = Expression(150) "[" Expression "]"
    |Dereferencing = DereferenceField | DereferenceMethod | StaticDereferenceField | StaticFunctionInvocation | ArrayDereference

    ### try-catch-finally
    $TryPart = "try" Expression
    $CatchBody = "(" VariableDeclaration ")" Expression
    ~CatchList = CatchBody : "catch"
    $CatchPart = "catch" CatchList
    $FinallyPart = "finally" Expression
    $TryCatch = TryPart CatchPart
    $TryFinally = TryPart FinallyPart
    $TryCatchFinally = TryPart CatchPart FinallyPart
    |TryGroup = TryCatch | TryFinally | TryCatchFinally

|Expression = LITERAL | FunctionInvocation | ID | -Operation | Block | -ControlStucture | VariableCreation | VariableDeclaration | -Dereferencing | -TryGroup

# | ControlStatement

### function definition
~ArgumentDeclarations = VariableDeclaration : ","
$FunctionDefinition = TypeId ID "(" ArgumentDeclarations ")" Expression

### Class
|ClassMember = FunctionDefinition    # | FieldDeclaration | FieldCreation
~ClassBody = (ClassMember) : ";"
$ClassDeclaration = "class" ID "{" ClassBody "}"

### CompilationUnit
~QualifiedName = ID : "."
$ImportClass = "import" QualifiedName "." "*" ";"
$ImportStar = "import" QualifiedName ";"
|ImportStatement = ImportStar | ImportClass
~Imports = ImportStatement : ""
$CompilationUnit = Imports ClassDeclaration

!Root = CompilationUnit

